# Переменная типа структура содержит в себе несколько именованных полей.
# Например, возвращаясь к задаче сортировки людей по убыванию роста,
# нам было бы удобно хранить описание каждого человека в виде структуры с двумя полями: ростом и именем.

# В чистом виде типа данных "структура" в стандарте языка Питон нет.
# Есть несколько способов реализации аналога структур: namedtuple из
# библиотеки collections, использование словарей (будет рассмотрено
# в следующих лекциях) или использование классов в качестве структур.
# Рассмотрим на примере последний способ.

# Напомним условие задачи: людей нужно упорядочить по убыванию роста,
# но в случае одинакового роста они должны быть упорядочены по фамилии.
# Решение с использованием классов в качестве структур будет выглядеть так:
class Man:
    height = 0
    name = ''

def manKey(man):
    return (-man.height, man.name)

n = int(input())
peopleList = []
for i in range(n):
    tempManData = input().split()
    man = Man()
    man.height = int(tempManData[0])
    man.name = tempManData[1]
    peopleList.append(man)
peopleList.sort(key=manKey)
for man in peopleList:
    print(man.height, man.name)

# Для того чтобы пользоваться классами как структурами мы создаем новый тип данных Man.
# В описании класса мы перечисляем имена всех полей и их значения по-умолчанию.

# В дальнейшем мы можем создавать объекты класса Man (это делается строкой man = Man()),
# которые сначала проинициализируют свои поля значениями по умолчанию. Доступ к полям класса осуществляется через точку.

# Функция сравнения принимает объект класса и генерирует ключ, по которому эти объекты будут сравниваться при сортировке.

# Использование структур для описания сложных объектов намного предпочтительнее,
# чем использование кортежей. При количестве параметров больше двух использование
# кортежей запутывает читателя и писателя кода, т.к. совершенно невозможно понять
# что хранится в badNamedTuple[13] и легко понять что хранится в goodNamedStruct.goodNamedField.

# Сейчас мы научимся создавать функции, которые принимают именованные параметры.
# Например, напишем функцию, печатающую что угодно итерируемое, состоящее
# из чего угодно приводимого к строке, с именованным параметром sep, по-умолчанию равным пробелу:

def printList(myList, sep=' '):
    print(sep.join(map(str, myList)))

printList([1, 2, 3])
printList([3, 2, 1], sep='\n')

# Именованный параметр в объявлении функции должен идти после основных параметров.
# В списке параметров записывается его имя, а затем значение по-умолчанию
# (т.е. то значение, которое будет подставляться на место соответствующего параметра, если он не был передан при вызове функции).

# Также мы пользовались функциями, которые умеют принимать произвольное количество
# параметров. Например, в функцию print можно передать любое количество параметров.
# Можно написать собственные функции, которые будут принимать произвольное количество
# параметров. При этом параметры функции будут упакованы в список. Например,
# функция подсчета суммы всех переданных параметров может выглядеть так:

def mySum(*args):
    nowSum = 0
    for now in args:
        nowSum += now
    return nowSum

print(mySum(1, 2))
print(mySum(1, 2, 3, 4))

# Функция принимает один параметр, перед которым написана
# звездочка - это признак того, что аргументы будут упакованы в список.

# Можно писать функции, которые принимают не менее определенного количества параметров.
# Например, мы можем написать функцию поиска минимума среди неопределенного числа аргументов,
# но в нее должно быть передано не менее одного аргумента:

def myMin(first, *others):
    nowMin = first
    for now in others:
        if now < nowMin:
            nowMin = now
    return nowMin

print(myMin(1))
print(myMin(3, 1, 2))

# Параметр со звездочкой всегда должен быть последним, за исключением ситуации, когда в функции также определены именованные параметры.

