# Штаб гражданской обороны Тридесятой области решил обновить план спасения
# на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной
# прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений
# могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
# Формат ввода
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000).
# Четвертая строка
# содержит m различных целых чисел, i-е из этих чисел задает
# расстояние от начала
# дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹.
# Селение и убежище могут располагаться в одной точке.
# Формат вывода
# Выведте n чисел - для каждого селения выведите номер ближайшего к нему
# бомбоубежища. Бомбоубежища пронумерованы от 1 до m в
# том порядке, в котором они заданы во входных данных.
# Указание
# Создайте список кортежей из пар (позиция селения, его номер в исходном
# списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему
# селению не обязательно искать ближайшее
# бомбоубежище с самого начала. Его можно искать начиная с позиции, найденной
# для предыдущего города. Аналогично, не нужно искать подходящее бомбоубежище
# до конца списка бомбоубежищ: достаточно найти самое близкое.
# Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.
# Примеры

n = int(input())
np = list(map(int, input().split()))
# Здесь создали 3-е поле для номера бомбоубежища
for i in range(n):
    np[i] = [np[i], i + 1, 0]
np.sort()

m = int(input())
bu = list(map(int, input().split()))
for i in range(m):
    bu[i] = [bu[i], i + 1]
bu.sort()


def civil_defender(n, np, m, bu):
    # Переменная для начала вложенного цикла
    start = 0
    for i in range(n):
        # Точка нахождения нужного бомбоубежища
        idx = 0
        # Чтобы минимум был точно больше любого найденного
        minimum = 10e10
        for j in range(start, m):
            tmp = abs(np[i][0] - bu[j][0])
            if tmp < minimum:
                # Либо обновляем минимум и номер бомбоубежища
                idx = j
                minimum = tmp
                np[i][2] = bu[j][1]
    # Либо заканчиваем цикл
            else:
                break
        # Переопределяем начало вложенного цикла
            start = idx

    np.sort(key=lambda idx: idx[1])
    # Получаем упорядоченный согласно порядка ввода список населённых пунктов и
    # назначенных им бомбоубежищ. В качестве отладки такое:
    for i in range(len(np)):
        print(np[i][2], end=' ')


civil_defender(n, np, m, bu)
