# Штаб гражданской обороны Тридесятой области решил обновить план спасения
# на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной
# прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений
# могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
# Формат ввода
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка
# содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала
# дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹.
# Селение и убежище могут располагаться в одной точке.
# Формат вывода
# Выведте n чисел - для каждого селения выведите номер ближайшего к нему
# бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# Указание
# Создайте список кортежей из пар (позиция селения, его номер в исходном
# списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему селению не обязательно искать ближайшее
# бомбоубежище с самого начала. Его можно искать начиная с позиции, найденной
# для предыдущего города. Аналогично, не нужно искать подходящее бомбоубежище
# до конца списка бомбоубежищ: достаточно найти самое близкое.
# Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.
# Примеры

a = int(4)
a2 = (79, 64, 13, 8, 38, 29, 58, 20, 56, 17)
a2sort = list(a2[:])
a2sort.sort()

b = int(2)
b2 = (53, 19, 20, 85, 82, 39, 58, 46, 51, 69)
b2sort = list(b2[:])
b2sort.sort()

finish = []

def civil_defense(a2, b2):
    for i in range(len(a2sort)):
        min_num_count = 0
        min_num = abs(a2sort[i] - b2sort[0])
        for j in range(len(b2sort)):
            if abs(a2sort[i] - b2sort[j]) < min_num:
                min_num = abs(a2sort[i] - b2sort[j])
                min_num_count = j
        finish.append(b2.index(b2sort[min_num_count])+1)
            
    print(finish)
            
    print(finish)


civil_defense(a2, b2)
