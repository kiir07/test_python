# Штаб гражданской обороны Тридесятой области решил обновить план спасения
# на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной
# прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений
# могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
# Формат ввода
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных
# данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая
# строка
# содержит m различных целых чисел, i-е из этих чисел задает расстояние от
#  начала
# дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹.
# Селение и убежище могут располагаться в одной точке.
# Формат вывода
# Выведте n чисел - для каждого селения выведите номер ближайшего к нему
# бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в
# котором они заданы во входных данных.
# Указание
# Создайте список кортежей из пар (позиция селения, его номер в исходном
# списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему селению не обязательно
# искать ближайшее
# бомбоубежище с самого начала. Его можно искать начиная с позиции, найденной
# для предыдущего города. Аналогично, не нужно искать подходящее бомбоубежище
# до конца списка бомбоубежищ: достаточно найти самое близкое.
# Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.
# Примеры

a = int(input())
a2 = list(map(int, input().split()))
a2sort = list(a2)
a2sort.sort()

b = int(input())
b2 = list(map(int, input().split()))
b2sort = list(b2)
b2sort.sort()

finish = []



def civil_defense(a, a2, a2sort, b, b2, b2sort):
    indx_j = 0
    for i in range(len(a2sort)):
        min_num_count = 0
        min_num = abs(a2sort[i] - b2sort[indx_j])
        
        if min_num > abs(a2sort[i] - b2sort[indx_j + 1]):
            min_num = abs(a2sort[i] - b2sort[indx_j + 1])
            min_num_count = indx_j + 1
            indx_j = min_num_count
        elif min_num <= abs(a2sort[i] - b2sort[indx_j]):
            pass

        finish.append(b2.index(b2[min_num_count])+1)

    print(*finish)

civil_defense(a, a2, a2sort, b, b2, b2sort)
