# # список с числами от 1 до 5: myList = [1, 2, 3, 4, 5].
# Списки и кортежи легко преобразуются друг в друга.
# Для преобразования списка в кортеж надо использовать уже
# известную нам функцию tuple, а для преобразования кортежа
# в список нужна функция list. Также функцию list можно применить к строке.
# В результате этого получится список, каждым элементом которого будет буква из строки. Так list('abc') будет выглядеть как ['a', 'b', 'c'].

# К спискам также применима функция len и срезы, которые работают также как в кортежах.

# Главным отличием списка от кортежа является изменяемость. То есть можно взять определенный элемент списка и изменить его (он может быть в левой части операции присваивания).

myList = [1, 2, 3]
myList[1] = 4
print(myList)

# будет напечатано [1, 4, 3].

# Изменение списков
# Список, как и другие типы в языке Питон, является ссылкой на список ссылок.
# При этом список является изменяемым объектом, т. е. содержимое по этой ссылке может поменяться. Рассмотрим такой пример:

a = [1, 2]
b = a
b[0] = 3
print(a)


# В результате выполнения этой программы будет напечатано [3, 2]. Это связано с тем,
# что присваивание в Питоне - это просто "привязывание" нового "ярлычка" к объекту.
# После присваивания b = a обе ссылки начинают показывать на один и тот же объект и
# если он изменен по одной ссылке, то по второй ссылке он также будет доступен в измененном состоянии.

a = [1, 2]
b = a
a = [3, 4]
print(b)


# будет выведено [1, 2]. Сначала в памяти создается объект [1, 2] и к нему привязывается ссылка a,
# затем к тому же объекту привязывается ссылка b, а затем создается новый объект [3, 4],
# к которому привязывается ссылка a (отвязавшись от своего предыдущего значения).
# При этом ссылка b не изменилась (она может измениться только если b будет участвовать в левой части присваивания) и по-прежнему показывает на [1, 2].

# Если списки переданы в функцию в качестве параметров, то их содержимое также может быть изменено этой функцией:


def replaceFirst(myList):
    myList[0] = 'x'
    
nowList = list('abcdef')
replaceFirst(nowList)
print(nowList)



# Выводе этой программы будет ['x', 'b', 'c', 'd', 'e', 'f'].

# Однако, сама ссылка внутри функции не может быть изменена, если она передана как параметр функции. Рассмотрим пример:

def reverseList(funcList):
    funcList = funcList[::-1]
    
mainList = list('abc')
reverseList(mainList)
print(mainList)

# Здесь в основной программе конструируется объект ['a', 'b', 'c'] и
# к нему привязывается ссылка mainList. При передаче mainList в качестве параметра
# в функцию создастся еще одна ссылка funcList, показывающая на объект ['a', 'b', 'c']
#  В результате применения среза создастся новый объект ['c', 'b', 'a'] и ссылка funcList начнет указывать на него.
#  Однако, значение ссылки mainList при этом не изменится и со значениями по ссылке mainList также ничего не произойдет
#  (напомним, что операция среза создает новый объект, не изменяя старый).



